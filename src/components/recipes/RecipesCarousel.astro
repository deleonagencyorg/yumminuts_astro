---
import RecipeCardCarousel from './RecipeCardCarousel.astro';
import { getLocale } from '../../i18n/i18n';

// Import all recipe files dynamically (use static glob and filter by lang)
const currentLang = getLocale();
interface Recipe {
  id: string;
  title: string;
  image: string;
  hover_image?: string;
  preparation_time: number;
  category?: string;
  category_en?: string;
  categories?: string[];
  categories_en?: string[];
  difficulty?: string;
  servings?: number;
  rating?: number;
}

// Optional items can be passed from parent (e.g., related recipes)
export interface Props {
  title?: string;
  textButton?: string;
  items?: any[]; // permitir arrays compatibles (e.g., RecipeItem)
  limit?: number; // limitar el número de recetas mostradas
}

const {
  textButton = currentLang === 'es' ? 'Ver Todas' : 'View All',
  items,
  limit
} = Astro.props as { textButton?: string; items?: any[]; limit?: number };

// If items provided, use them; otherwise load all by lang
let recipeItems: Recipe[] = Array.isArray(items) ? (items as unknown as Recipe[]) : [];
if (!recipeItems.length) {
  const recipeModules = import.meta.glob<{ default: Recipe }>("../../locales/*/recipes/*.json");
  for (const path in recipeModules) {
    // Path format: ../../locales/es/recipes/file.json
    const pathParts = path.split('/');
    const lang = pathParts[pathParts.length - 3]; // Get 'es' or 'en' from path
    if (lang === currentLang) {
      const mod = await recipeModules[path]();
      recipeItems.push(mod.default);
    }
  }
}

// Aplicar límite si está definido
if (limit && limit > 0 && recipeItems.length > limit) {
  recipeItems = recipeItems.slice(0, limit);
}

// Determine if we are in provided-items mode (hide filters/CTA)
const providedMode = Array.isArray(items) && items.length > 0;

// Normalizar categoría (usando claves en inglés para el filtrado)
function getCategoryKey(recipe: any): string {
  const raw = (
    recipe?.category_en ||
    recipe?.category ||
    recipe?.category?.name ||
    (Array.isArray(recipe?.categories_en) ? recipe.categories_en[0] : undefined) ||
    (Array.isArray(recipe?.categories) ? recipe.categories[0] : undefined) ||
    ''
  );
  const key = String(raw || '').trim().toLowerCase();
  // mapear posibles variaciones a claves conocidas
  if (['breakfast', 'desayuno', 'desayunos'].includes(key)) return 'breakfast';
  // Mapear brunch a snacks según la taxonomía del proyecto
  if ([
    'snack', 'snacks', 'snack energeticos', 'snack energético', 'snack energéticos', 'snack-energeticos', 'energy snacks', 'brunch'
  ].includes(key)) return 'snacks';
  if (['lunch', 'almuerzo', 'almuerzos'].includes(key)) return 'lunch';
  if (['dinner', 'cena', 'cenas'].includes(key)) return 'dinner';
  return key || 'other';
}

// Etiquetas por idioma (solo UI)
const filterLabels = currentLang === 'es'
  ? { breakfast: 'Desayunos', snacks: 'Snack Energéticos', lunch: 'Almuerzos', dinner: 'Cenas', all: 'Todas' }
  : { breakfast: 'Breakfast', snacks: 'Energy Snacks', lunch: 'Lunch', dinner: 'Dinner', all: 'All' };

// Para desktop: mostrar 4 tarjetas por vista, avanzar de 1 en 1
// Para mobile: 1 por slide (mejor ajuste a pantalla)
const mobileGroups = [] as any[];
for (let i = 0; i < recipeItems.length; i += 1) {
  mobileGroups.push([recipeItems[i]].filter(Boolean));
}

---

<div class="w-full" data-recipes-carousel>
  <div class="w-full px-4 ">
    <!-- Título alineado a la izquierda -->
    
    <!-- Seccion de recetas -->
    
    <!-- Botones de filtro -->
    {!providedMode && (
    <div class="grid grid-cols-2 gap-3 mb-6 max-w-md mx-auto md:max-w-none md:flex md:justify-start md:gap-2.5 px-4 md:px-0" id="recipesFilters">
      <button type="button" data-filter="breakfast" class="filter-btn w-full text-center px-4 py-2 rounded-md bg-secondary text-primary font-bold hover:text-primary hover:bg-secondary hover:opacity-100 transition-colors border border-white">
        {filterLabels.breakfast}
      </button>
      <button type="button" data-filter="snacks" class="filter-btn w-full text-center px-4 py-2 rounded-md bg-secondary text-primary font-bold hover:text-primary hover:bg-secondary hover:opacity-100 transition-colors border border-white">
        {filterLabels.snacks}
      </button>
      <button type="button" data-filter="lunch" class="filter-btn w-full text-center px-4 py-2 rounded-md bg-secondary text-primary font-bold hover:text-primary hover:bg-secondary hover:opacity-100 transition-colors border border-white">
        {filterLabels.lunch}
      </button>

      <button type="button" data-filter="all" class="filter-btn w-full text-center px-4 py-2 rounded-md bg-secondary text-primary font-bold hover:text-primary hover:bg-secondary hover:opacity-100 transition-colors border border-white">
        {filterLabels.all}
      </button>
    </div>
    )}
     
    <!-- Carousel de recetas - MOBILE (1 por slide) - Solo visible en mobile -->
    <div class="recipes-carousel-mobile relative md:hidden">
      <div class="recipes-carousel-container overflow-hidden w-full">
        <div class="recipes-carousel-track flex items-start w-full gap-0 transition-transform duration-300" id="recipesTrackMobile" style="transform: translateX(0);">
          {mobileGroups.map((group, gIndex) => (
            <div class="recipe-slide-group flex-shrink-0 w-full flex gap-4 px-2">
              {group.map((recipe: any) => (
                <div class="recipe-slide w-full" data-category={getCategoryKey(recipe)}>
                  <RecipeCardCarousel
                    image={recipe.image}
                    hoverImage={recipe.hover_image || recipe.image}
                    title={recipe.title}
                    time={`${recipe.preparation_time}MIN`}
                    id={recipe.id}
                    difficulty={recipe.difficulty || '---'}
                    servings={recipe.servings || 0}
                    rating={recipe.rating || 0}
                    isMainCard={false}
                  />
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>

      <!-- Controles de navegación mobile (flechas y puntos) -->
      <div class="flex justify-center items-center gap-4 mt-6">
        <button class="carousel-prev bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Anterior" id="prevBtnMobile">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <div class="carousel-dots-mobile flex gap-2"></div>

        <button class="carousel-next bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Siguiente" id="nextBtnMobile">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Carousel de recetas - DESKTOP - Solo visible en desktop -->
    <div class="recipes-carousel relative hidden md:block">
      <div class="recipes-carousel-container overflow-visible ">
        <div class="recipes-carousel-track flex items-start justify-center w-full gap-4 md:gap-6 transition-transform duration-300" id="recipesTrackDesktop" style="transform: translateX(0);">
          {recipeItems.map((recipe, index) => (
            <div class="recipe-slide w-1/4 px-2 flex-shrink-0 group-hover-container" data-index={index} data-category={getCategoryKey(recipe)}>
              <RecipeCardCarousel
                image={recipe.image}
                hoverImage={recipe.hover_image || recipe.image}
                title={recipe.title}
                time={`${recipe.preparation_time}MIN`}
                id={recipe.id}
                difficulty={recipe.difficulty || '---'}
                servings={recipe.servings || 0}
                rating={recipe.rating || 0}
                isMainCard={false}
              />
            </div>
          ))}
        </div>
      </div>
      
      <!-- Controles de navegación desktop (flechas y puntos en la parte inferior) -->
      <div class="flex justify-center items-center gap-4 mt-8">
        <!-- Flecha anterior -->
        <button class="carousel-prev bg-white text-primary p-2 rounded-full shadow-lg z-10" aria-label="Anterior" id="prevBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
        
        <!-- Puntos indicadores -->
        <div class="carousel-dots-desktop flex gap-2"></div>
        
        <!-- Flecha siguiente -->
        <button class="carousel-next bg-white text-primary p-2 rounded-full shadow-lg z-10" aria-label="Siguiente" id="nextBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Botón "Ver Todas" - oculto cuando se proveen items -->
    {!providedMode && (
    <div class="flex justify-center mt-6 w-full px-4 md:px-0">
      <a href={`/${currentLang === 'es' ? 'es/recetas' : 'en/recipes'}`} class=" px-4 py-2 text-md rounded-md border  bg-secondary font-bold text-blue hover:bg-primary hover:text-white transition-colors">
        {textButton}
      </a>
    </div>
    )}
  </div>
</div>

<script>
  function initRecipesCarousel(root) {
    if (!root || root.dataset.rcInitialized === 'true') return;
    root.dataset.rcInitialized = 'true';
    // Estado de filtro actual
    let currentFilter = 'all';

    // Setup filtros
    const filtersContainer = root.querySelector('#recipesFilters');
    const filterButtons = Array.from(filtersContainer?.querySelectorAll('.filter-btn'));

    // Configuración para el carrusel mobile
    setupMobileCarousel();

    // Configuración para el carrusel desktop
    setupDesktopCarousel();

    // Eventos de filtros
    filterButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        const filter = btn.getAttribute('data-filter') || 'all';
        currentFilter = filter;
        // estilos activos
        filterButtons.forEach(b => b.classList.remove('ring-2', 'ring-brown'));
        btn.classList.add('ring-2', 'ring-brown');
        // aplicar filtros
        applyFilterMobile();
        applyFilterDesktop();
      });
    });

    // Función para configurar el carrusel mobile
    function setupMobileCarousel() {
      applyFilterMobile(true);
    }

    function applyFilterMobile(initial = false) {
      const track = root.querySelector('#recipesTrackMobile');
      const prevBtn = root.querySelector('#prevBtnMobile');
      const nextBtn = root.querySelector('#nextBtnMobile');
      const dotsContainer = root.querySelector('.carousel-dots-mobile');

      if (!track || !prevBtn || !nextBtn || !dotsContainer) return;

      const allGroups = Array.from(track.querySelectorAll('.recipe-slide-group'));
      // Mostrar/ocultar grupos según filtro (cada grupo tiene 1 slide)
      allGroups.forEach((group) => {
        const slide = group.querySelector('.recipe-slide');
        const cat = slide?.getAttribute('data-category') || '';
        const visible = (currentFilter === 'all') || (cat === currentFilter);
        group.style.display = visible ? '' : 'none';
      });

      const visibleGroups = allGroups.filter(g => g.style.display !== 'none');
      let currentGroup = 0;

      // Handlers prev/next: reset listeners para evitar acumulación
      const prevClone = prevBtn.cloneNode(true);
      const nextClone = nextBtn.cloneNode(true);
      prevBtn.parentNode?.replaceChild(prevClone, prevBtn);
      nextBtn.parentNode?.replaceChild(nextClone, nextBtn);

      createDots();
      updatePosition();

      prevClone.addEventListener('click', () => {
        if (currentGroup > 0) {
          currentGroup--;
          updatePosition();
        }
      });

      nextClone.addEventListener('click', () => {
        if (currentGroup < visibleGroups.length - 1) {
          currentGroup++;
          updatePosition();
        }
      });

      function createDots() {
        dotsContainer.innerHTML = '';
        for (let i = 0; i < visibleGroups.length; i++) {
          const dot = document.createElement('button');
          dot.classList.add('w-3', 'h-3', 'rounded-full', i === currentGroup ? 'bg-white' : 'bg-gray-300');
          dot.addEventListener('click', () => {
            currentGroup = i;
            updatePosition();
          });
          dotsContainer.appendChild(dot);
        }
      }

      function updatePosition() {
        // Calcular índice real de grupo visible
        const targetGroup = visibleGroups[currentGroup];
        const originalIndex = allGroups.indexOf(targetGroup);
        const percent = Math.max(0, originalIndex) * 100;
        track.style.transform = `translateX(-${percent}%)`;

        // Actualizar dots
        const dots = dotsContainer.querySelectorAll('button');
        dots.forEach((dot, i) => {
          if (i === currentGroup) {
            dot.classList.remove('bg-gray-300');
            dot.classList.add('bg-white');
          } else {
            dot.classList.remove('bg-white');
            dot.classList.add('bg-gray-300');
          }
        });

        // Habilitar/deshabilitar botones
        prevClone.classList.toggle('opacity-50', currentGroup === 0);
        nextClone.classList.toggle('opacity-50', currentGroup >= visibleGroups.length - 1);
      }
    }

    // Función para configurar el carrusel desktop
    function setupDesktopCarousel() {
      applyFilterDesktop(true);
    }

    function applyFilterDesktop(initial = false) {
      const track = root.querySelector('#recipesTrackDesktop');
      const prevBtn = root.querySelector('#prevBtnDesktop');
      const nextBtn = root.querySelector('#nextBtnDesktop');
      const dotsContainer = root.querySelector('.carousel-dots-desktop');

      if (!track || !prevBtn || !nextBtn || !dotsContainer) return;

      const allSlides = Array.from(track.querySelectorAll('.recipe-slide'));
      // Mostrar/ocultar slides según filtro
      allSlides.forEach((slide) => {
        const cat = slide.getAttribute('data-category') || '';
        const visible = (currentFilter === 'all') || (cat === currentFilter);
        slide.style.display = visible ? 'block' : 'none';
      });

      const visibleSlides = allSlides.filter(s => s.style.display !== 'none');
      let currentSlide = 0;

      // Resetear listeners para evitar acumulación
      const prevClone = prevBtn.cloneNode(true);
      const nextClone = nextBtn.cloneNode(true);
      prevBtn.parentNode?.replaceChild(prevClone, prevBtn);
      nextBtn.parentNode?.replaceChild(nextClone, nextBtn);

      updateDesktopCarousel();
      createDesktopDots();

      prevClone.addEventListener('click', () => {
        if (currentSlide > 0) {
          currentSlide--;
          updateDesktopCarousel();
        }
      });

      nextClone.addEventListener('click', () => {
        if (currentSlide < Math.max(0, visibleSlides.length - 4)) {
          currentSlide++;
          updateDesktopCarousel();
        }
      });

      function createDesktopDots() {
        dotsContainer.innerHTML = '';
        const totalDots = Math.max(0, visibleSlides.length - 3); // totalSlides - 4 + 1
        for (let i = 0; i < totalDots; i++) {
          const dot = document.createElement('button');
          dot.classList.add('w-3', 'h-3', 'rounded-full', i === currentSlide ? 'bg-white' : 'bg-gray-300');
          dot.addEventListener('click', () => {
            currentSlide = i;
            updateDesktopCarousel();
          });
          dotsContainer.appendChild(dot);
        }
      }

      function updateDesktopCarousel() {
        // Solo controla visibilidad por ventana de 4, sin mutar estilos internos de la tarjeta
        visibleSlides.forEach((slide, index) => {
          slide.style.removeProperty('width');
          slide.style.removeProperty('transition');
          const visible = index >= currentSlide && index < currentSlide + 4;
          slide.style.display = visible ? 'block' : 'none';

          // Hover: solo opacidad de vecinos, sin cambiar tamaños
          if (visible && !slide.dataset.dimInit) {
            slide.dataset.dimInit = 'true';
            slide.addEventListener('mouseenter', () => {
              visibleSlides.forEach((s) => {
                if (s.style.display !== 'none') {
                  const a = s.querySelector('a');
                  if (!a) return;
                  if (s === slide) {
                    a.style.opacity = '1';
                    a.style.zIndex = '10';
                  } else {
                    a.style.opacity = '0.35';
                    a.style.zIndex = '1';
                  }
                }
              });
            });
            slide.addEventListener('mouseleave', () => {
              visibleSlides.forEach((s) => {
                const a = s.querySelector('a');
                if (!a) return;
                a.style.opacity = '1';
                a.style.zIndex = '';
              });
            });
          }
        });

        // Actualizar dots
        const dots = dotsContainer.querySelectorAll('button');
        dots.forEach((dot, i) => {
          if (i === currentSlide) {
            dot.classList.remove('bg-gray-300');
            dot.classList.add('bg-white');
          } else {
            dot.classList.remove('bg-white');
            dot.classList.add('bg-gray-300');
          }
        });

        // Habilitar/deshabilitar botones
        prevClone.classList.toggle('opacity-50', currentSlide === 0);
        nextClone.classList.toggle('opacity-50', currentSlide >= Math.max(0, visibleSlides.length - 4));
      }
    }
  }

  // Inicializaciones para navegaciones parciales de Astro y carga inicial
  function initAll() {
    document.querySelectorAll('[data-recipes-carousel]')
      .forEach((el) => initRecipesCarousel(el));
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll);
  } else {
    initAll();
  }
  document.addEventListener('astro:page-load', initAll);
  document.addEventListener('astro:after-swap', initAll);
</script>
